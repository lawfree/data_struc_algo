p105 Boggle 
分析时间复杂度
	那么此时检索的答案共有多少?到达最后一个格子之前,函数会一直递归调用.每个格子有8个相邻的格子,
	函数会根据单词的长度进行N-1次检索.最终,检索的大男个数为8^(N-1),由此算法时间复杂度为O(8^N)

穷据搜索方案
	利用穷举搜索法解决问题必经过程如下.虽然此过程不适用所有问题,但为解题指出大致方向
		穷举搜索会检索所有可能的答案,耗时会正比于可能的答案个数.应利用最大值输入求出可能答案的个数,然后判断是否在限定时间内完成所有操作.
		把检索可能答案的过程分为若干个选择.选择将成为每个可能答案的计算过程.
		挑其中1个选择计算出一个候选答案,剩余答案通过递归调用进行计算
		只剩一个候选或没有剩下选择时,如果能得到答案,就把这些情况纳入初始部分
理论背景:递归调用和子问题
	能够利用递归调用解决的"问题",必须是要执行的操作和用于操作的数据相互组合的形态
	boggle中,问题定义为"在棋盘当前位置(y,x)并给出单词word,判断从这个位置出发能否找到相应单词".为得出结果,最多需要9种信息.
		1.	当前位置(y,x)中是否有首字母;
		2.从上一格(y - 1 , x - 1)起始,能否找出剩余全部字母
		3. ...
	从第二项开始,只是比上一项少一个计算步骤,其余都是相同形式的操作.


6.10常见穷举搜索类型
	计算给定元素的所有排列,给定元素中选取R个元素的所有方法等问题,往往以其他问题的子问题出现.
	因此有必要了解答案个数会根据输入值的大小发生怎样的变化,及其实现方法
生成所有排列
	把互不相同的N个元素排列成一列的方式称为排列.对给定元素生成所有排列后解决问题的情况较为常见.
	因此有必要针对生成所有排列的问题进行归纳,并编写代码.
	不过,可能的排列个数是N!.所以N超过10时,会很难在限定时间内完成计算.
生成所有组合
	在N个不同元素的无序选取R个元素的方法称为组合
生成2^n个数值
	假设n个提问都以是/否回答,那么可能的答案个数是2^n.生成这种组合解题也是非常普遍的一种方法.



分治
7.1 引言
	使用分治的算法具有以下3种构成要素
		把问题分解为更小问题的分解过程 divide
		把各个小问题的答案合并为原问题答案的合并过程 merge
		不需要再分解而直接解答的最基本问题 base case
	适用分治的问题必须具备以下几个特性:
		能够把问题自然分解为两个以上的子问题,且能够利用子问题的答案生成原问题的答案.优点在于很多情况下能更快解决同一问题.
		/*利用分治算法求1到n之和*/
		//必要条件: n是自然数
		//返回1+2+...+n的值
		int fastSum(int n){
			//初始部分
			if(n == 1) return 1;
			if(n % 2 == 1) return fastSum(n - 1) + n;
			return 2*fastSum(n/2) + (n/2) * (n/2); 
		}



7.1分治
无法均分的分解与时间复杂度
	表示两种分解方式pow（A，31）时所需子问题的依赖关系。如果计算pow(A,x)时需要调用pow(A,y),那么就用箭头将两个值连接到一起.
		a.对半分解单数情况
		b.从单数减一,变成双数情况
	计算pow(A,15)和pow(A,16)时都会调用a中的pow(A,8),所以pow(A,8)共被调用两次...
	这个实例说明了"同一个问题的不同分解方式会导致时间复杂度大不一样"的道理.采用对半分割方式的算法效率低下的原因是,子问题的重复计算导致耗费大量的运算时间.
	这种特性称为重叠子问题.


分治算法的设计
	为设计出分治算法,首先要确定以何种方式分割给定的问题.先把n个木板平均分割成两个子问题.那么我们期望的长方形会符合以下三种可能之一.
		最大面积的长方形只能在左侧的子问题中获得.
		最大面积的长方形只能在右侧的子问题中获得.
		最大面积的长方形横跨左右两侧的子问题.
	
	横跨左右两侧子问题的解法
		明白一个事实:该长方形必定横跨两个子问题边界的两个木板.假设从这个长方形开始分别向左右两侧一格一格扩展下去,既可向左侧一格,也可向右侧移动一格.
		那么选择"包含更高木板的右侧长方形".要找出面积最大的长方形,需要向长方形高度最大化方向寻找.全局数组h[]区间[left,right]将传递给递归函数solve().
		之后,函数将返回可在当前区间内截取的面积最大的长方形的宽




10.1贪心
	最直观的算法设计范式之一.利用贪心算法的求解方式与递归调用极为相似,都是先把问题分割成几个子问题,并在每个阶段生成一部分答案.
	从这一点看,贪心算法和穷举搜索和动态规划区别不大.不过,与"先考虑所有选项,再找出最优解"的穷举搜索算法和动态规划不同,贪心是在每个阶段即可找出最优解.
	
	贪心法在很多时候不能求出最优解.因此贪心法的使用范围会限制于如下两种情况:
		1.即使用贪心法也能求出最优解.贪心比dp具有更快的运算速度,所以在这种情况下会非常有用.
		2.因时间或空间限制二无法利用其他算法求出最优解时,可利用近似解替代最优解.这种情况下,利用贪心法求出的解虽然不是最优解,但比其他方法更接近最优解

活动选择问题
	能否用暴力解决法
		此题有多种答案,互不重叠的会议集合都是此题的答案,所要求的最优解就是这些集合的最大的一个.此题的暴力解决法就是,生成所有子集,并在其中找出不重叠的最大集合.
		不过,集合的大小是n的时候,子集的个数是2^n.所以n=30时,就不可能在限定时间内完成运算.
	构思贪心法
		考虑从开会时间最短的会议开始逐个检索,并找出不与前面的会议发生冲突的会议.这种方法可将使用会议室的时间变为最大.不过,算法只选择最短的一个,而不是选择两个唱的.
		由此可见使用贪心的算法原理上可行,但不能保证一定能够得到正确答案.
		
		解决此问题的贪心法应该从最早结束的会议开始选择.选择最早结束的会议后,删除与这个会议冲突的会议,然后再从中选择最早结束的会议.反复进行此操作就能得到最终答案.
		算法具有如下结构:
			1.在会议室目录中S中选取最早结束的会议Smin
			2.在会议目录S中删除与Smin发生冲突的会议
			3.重复上述两步骤直到S为空
		使用此方法是否能够选出最多的会议?
	
	正确性证明:贪心选择性质
		贪心法的正确性证明在很多情况下会表现一种特定模式,这种模式通过证明两个属性体现贪心法求出的最优解的正确性.
		第一个要证明的属性是,就像动态规划一样,在不考虑整体答案的前提下,只使用贪心法进行选择,也能够求出最优解.
		这种属性被称为贪心选择性.
		若一个算法中这种性质成立,那么在各个阶段进行贪心选择将是求出最优解的途径之一.这也就说明,贪心选择不会产生任何损失.如果上面提出的算法贪心选择性成立,
		那么意味着下面的条件也将会成立:
			必定存在一个最优解包含最早结束的会议(Smin).
		
			证明:	假设S的最优解中有一个不包含Smin的答案.这个解是一个相互不重叠的会议记录,在这个目录中删除第一个要举行的会议后,添加Smin生成一个新目录.
						因Smin是S中最先结束的会议(或之一),被删除的会议不可能在Smin之前结束.因此,第二个会议也不可能与Smin发生冲突.这说明,新生成的目录也是一个最优解,而且也可以
						证明出包含Smin的最优解是存在的.这个证明说明,不存在"选择最先结束的会议而求不出最优解"的情况.
	
	最优子结构
		即使已经证明了贪心选择能够求出最优解,但整个证明还未结束.还需要证明,算法始终做出最佳选择,并能够求出最终的最优解.比如,做出第一个选择后,剩余部分需使用非最优的方法解决.
		为了证明贪心法的正确性,需要证明的第二个属性就是最优子结构.

	实现方法
		首先把会议按照结束时间的升序排列.这时可以先选择第一个会议,然后并不需要删除重叠会议,而是检索已排序好的数组,选出与第一个会议不发重叠的会议即可.
		会议已按照升序排列,所以找不到不重叠的会议后,不用再检索其他会议,直接选用即可.



制定参数顺序
			A 队出场顺序与历史分数表		3000	2700	2800	2200	2500	1900
			B 队出场顺序与历史分数表		2800	2750	2995	1800	2600	2000
	假设历史分数高的队伍一定获胜,则B队按此出场顺序会获得第2,3,5,6场的胜利.此时若把第一场和第四位选手调换,则会赢得除第一场外的剩余5场胜利.
	已知对方的出场顺序时,该制定什么样的参赛顺序才能赢得更多的场次呢?
	在本题中A是对手,B是我方

能不能用暴力法?
	每队有n位选手,故共有n!个答案.

能不能用动态规划法?
	

构造贪心算法
	如果每个队有100名选手?此时只能设计一个比动态规划更快的算法.设计贪心的技巧是,先拿几个简单输入值进行手算,并找出其中的一些模式.其中下面的算法比较直观.
	
	从第一场比赛开始指定出场选手.在能够战胜对方的选手中,选择评分最低的选手,那些评分高的选手留着以后再用.为了证明此方法的正确性,要先证明总是存在一个包含这种选择的最优解.
	先把各个比赛分成"只能输掉"和"肯定能赢"两种情况,由此证明进行的选择是正确的.
	
	先考虑只能输掉的情况.对方选手的评分高于己方任何一个选手的评分时,将不可能赢该场比赛.假设这场比赛有一个最优解,即让B代替评分最低的选手A上场.
	那么,在这个最优解中把两个选手调换过来,又会如何? 虽然这场比赛肯定会输,但与A对战的x 将会对战评分更高的选手.所以取胜场次至少不会减少.
	由此可见,存在一个最优解使A参加这场比赛.
	
	接下来考虑能够取胜的情况.己方选手只要有一个比对方当前选手的评分更高或者相同的选手,就能取胜.那么,假设有一个最优解,使得评分跟高的B替代能够战胜对方的选手中评分最低的A参赛.
	在这个最优解中调换A和B的位置.虽然肯定会赢,但与A对战的x将对战评分更高的选手.由此可见,这种比赛也是一个最优解.那么有没有可能选择比A的评分更小的选手呢?
	加入有一个最优解能够让C代替A出场,那么就会输掉本来赢的比赛.因此,在这最优解中,如果调换A和C的顺序就能重新获胜.
	
	通过上面证明就能看出,做出的选择能够保障最多的取胜次数.

	现在可以看出证明贪心选择性的模式:
		这种模式为了证明存在一个包含所做选择的最优解,先假定有一个不包含所做选择的最优解,然后对此进行适当调整,生成包含所做选择的最优解.这种模式在证明贪心法正确性的时候常用

证明最优子结构
	选择完第一个参数选手,就能得出剩余选手的子问题.


考虑两种情况:



设计贪心算法的步骤
	1.把生成答案的过程分成几个分割块
	2.决定以何种优先顺序选择各分割块.为了更加直观地解题,可以先利用示例输入值或几个简单的输入值进行手算.
	3.确定了可行的房事后,证明两个性质.
		a)贪心选择性的证明: 证明出每个阶段存在一个最优解,总是包含做出的选择.此证明一般假设存在已做出选择的答案和另一个最优解,
			然后对此进行适当调整,使其变成包含已选择的答案的最优解.
		b)最优子结构的证明:在各个阶段总是做出最优选择时,证明能够得到整个问题的最优解.这个性质大多数情况下都能够不证自明.
		





		
		
		
	


