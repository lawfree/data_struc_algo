p105 Boggle 
分析时间复杂度
	那么此时检索的答案共有多少?到达最后一个格子之前,函数会一直递归调用.每个格子有8个相邻的格子,
	函数会根据单词的长度进行N-1次检索.最终,检索的大男个数为8^(N-1),由此算法时间复杂度为O(8^N)

穷据搜索方案
	利用穷举搜索法解决问题必经过程如下.虽然此过程不适用所有问题,但为解题指出大致方向
		穷举搜索会检索所有可能的答案,耗时会正比于可能的答案个数.应利用最大值输入求出可能答案的个数,然后判断是否在限定时间内完成所有操作.
		把检索可能答案的过程分为若干个选择.选择将成为每个可能答案的计算过程.
		挑其中1个选择计算出一个候选答案,剩余答案通过递归调用进行计算
		只剩一个候选或没有剩下选择时,如果能得到答案,就把这些情况纳入初始部分
理论背景:递归调用和子问题
	能够利用递归调用解决的"问题",必须是要执行的操作和用于操作的数据相互组合的形态
	boggle中,问题定义为"在棋盘当前位置(y,x)并给出单词word,判断从这个位置出发能否找到相应单词".为得出结果,最多需要9种信息.
		1.	当前位置(y,x)中是否有首字母;
		2.从上一格(y - 1 , x - 1)起始,能否找出剩余全部字母
		3. ...
	从第二项开始,只是比上一项少一个计算步骤,其余都是相同形式的操作.


6.10常见穷举搜索类型
	计算给定元素的所有排列,给定元素中选取R个元素的所有方法等问题,往往以其他问题的子问题出现.
	因此有必要了解答案个数会根据输入值的大小发生怎样的变化,及其实现方法
生成所有排列
	把互不相同的N个元素排列成一列的方式称为排列.对给定元素生成所有排列后解决问题的情况较为常见.
	因此有必要针对生成所有排列的问题进行归纳,并编写代码.
	不过,可能的排列个数是N!.所以N超过10时,会很难在限定时间内完成计算.
生成所有组合
	在N个不同元素的无序选取R个元素的方法称为组合
生成2^n个数值
	假设n个提问都以是/否回答,那么可能的答案个数是2^n.生成这种组合解题也是非常普遍的一种方法.



分治
7.1 引言
	使用分治的算法具有以下3种构成要素
		把问题分解为更小问题的分解过程 divide
		把各个小问题的答案合并为原问题答案的合并过程 merge
		不需要再分解而直接解答的最基本问题 base case
	适用分治的问题必须具备以下几个特性:
		能够把问题自然分解为两个以上的子问题,且能够利用子问题的答案生成原问题的答案.优点在于很多情况下能更快解决同一问题.
		/*利用分治算法求1到n之和*/
		//必要条件: n是自然数
		//返回1+2+...+n的值
		int fastSum(int n){
			//初始部分
			if(n == 1) return 1;
			if(n % 2 == 1) return fastSum(n - 1) + n;
			return 2*fastSum(n/2) + (n/2) * (n/2); 
		}



7.1分治
无法均分的分解与时间复杂度
	表示两种分解方式pow（A，31）时所需子问题的依赖关系。如果计算pow(A,x)时需要调用pow(A,y),那么就用箭头将两个值连接到一起.
		a.对半分解单数情况
		b.从单数减一,变成双数情况
	计算pow(A,15)和pow(A,16)时都会调用a中的pow(A,8),所以pow(A,8)共被调用两次...
	这个实例说明了"同一个问题的不同分解方式会导致时间复杂度大不一样"的道理.采用对半分割方式的算法效率低下的原因是,子问题的重复计算导致耗费大量的运算时间.
	这种特性称为重叠子问题.


分治算法的设计
	为设计出分治算法,首先要确定以何种方式分割给定的问题.先把n个木板平均分割成两个子问题.那么我们期望的长方形会符合以下三种可能之一.
		最大面积的长方形只能在左侧的子问题中获得.
		最大面积的长方形只能在右侧的子问题中获得.
		最大面积的长方形横跨左右两侧的子问题.
	
	横跨左右两侧子问题的解法
		明白一个事实:该长方形必定横跨两个子问题边界的两个木板.假设从这个长方形开始分别向左右两侧一格一格扩展下去,既可向左侧一格,也可向右侧移动一格.
		那么选择"包含更高木板的右侧长方形".要找出面积最大的长方形,需要向长方形高度最大化方向寻找.全局数组h[]区间[left,right]将传递给递归函数solve().
		之后,函数将返回可在当前区间内截取的面积最大的长方形的宽




10.1贪心
	最直观的算法设计范式之一.利用贪心算法的求解方式与递归调用极为相似,都是先把问题分割成几个子问题,并在每个阶段生成一部分答案.
	从这一点看,贪心算法和穷举搜索和动态规划区别不大.不过,与"先考虑所有选项,再找出最优解"的穷举搜索算法和动态规划不同,贪心是在每个阶段即可找出最优解.
	
	贪心法在很多时候不能求出最优解.因此贪心法的使用范围会限制于如下两种情况:
		1.即使用贪心法也能求出最优解.贪心比dp具有更快的运算速度,所以在这种情况下会非常有用.
		2.因时间或空间限制二无法利用其他算法求出最优解时,可利用近似解替代最优解.这种情况下,利用贪心法求出的解虽然不是最优解,但比其他方法更接近最优解

活动选择问题
	能否用暴力解决法
		此题有多种答案,互不重叠的会议集合都是此题的答案,所要求的最优解就是这些集合的最大的一个.此题的暴力解决法就是,生成所有子集,并在其中找出不重叠的最大集合.
		不过,集合的大小是n的时候,子集的个数是2^n.所以n=30时,就不可能在限定时间内完成运算.
	构思贪心法
		考虑从开会时间最短的会议开始逐个检索,并找出不与前面的会议发生冲突的会议.这种方法可将使用会议室的时间变为最大.不过,算法只选择最短的一个,而不是选择两个唱的.
		由此可见使用贪心的算法原理上可行,但不能保证一定能够得到正确答案.
		
		解决此问题的贪心法应该从最早结束的会议开始选择.选择最早结束的会议后,删除与这个会议冲突的会议,然后再从中选择最早结束的会议.反复进行此操作就能得到最终答案.
		算法具有如下结构:
			1.在会议室目录中S中选取最早结束的会议Smin
			2.在会议目录S中删除与Smin发生冲突的会议
			3.重复上述两步骤直到S为空
		使用此方法是否能够选出最多的会议?
	
	正确性证明:贪心选择性质
		贪心法的正确性证明在很多情况下会表现一种特定模式,这种模式通过证明两个属性体现贪心法求出的最优解的正确性.
		
	


