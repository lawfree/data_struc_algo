p105 Boggle 
分析时间复杂度
	那么此时检索的答案共有多少?到达最后一个格子之前,函数会一直递归调用.每个格子有8个相邻的格子,
	函数会根据单词的长度进行N-1次检索.最终,检索的大男个数为8^(N-1),由此算法时间复杂度为O(8^N)

穷据搜索方案
	利用穷举搜索法解决问题必经过程如下.虽然此过程不适用所有问题,但为解题指出大致方向
		穷举搜索会检索所有可能的答案,耗时会正比于可能的答案个数.应利用最大值输入求出可能答案的个数,然后判断是否在限定时间内完成所有操作.
		把检索可能答案的过程分为若干个选择.选择将成为每个可能答案的计算过程.
		挑其中1个选择计算出一个候选答案,剩余答案通过递归调用进行计算
		只剩一个候选或没有剩下选择时,如果能得到答案,就把这些情况纳入初始部分
理论背景:递归调用和子问题
	能够利用递归调用解决的"问题",必须是要执行的操作和用于操作的数据相互组合的形态
	boggle中,问题定义为"在棋盘当前位置(y,x)并给出单词word,判断从这个位置出发能否找到相应单词".为得出结果,最多需要9种信息.
		1.	当前位置(y,x)中是否有首字母;
		2.从上一格(y - 1 , x - 1)起始,能否找出剩余全部字母
		3. ...
	从第二项开始,只是比上一项少一个计算步骤,其余都是相同形式的操作.


6.10常见穷举搜索类型
	计算给定元素的所有排列,给定元素中选取R个元素的所有方法等问题,往往以其他问题的子问题出现.
	因此有必要了解答案个数会根据输入值的大小发生怎样的变化,及其实现方法
生成所有排列
	把互不相同的N个元素排列成一列的方式称为排列.对给定元素生成所有排列后解决问题的情况较为常见.
	因此有必要针对生成所有排列的问题进行归纳,并编写代码.
	不过,可能的排列个数是N!.所以N超过10时,会很难在限定时间内完成计算.
生成所有组合
	在N个不同元素的无序选取R个元素的方法称为组合
生成2^n个数值
	假设n个提问都以是/否回答,那么可能的答案个数是2^n.生成这种组合解题也是非常普遍的一种方法.



分治
7.1 引言
	使用分治的算法具有以下3种构成要素
		把问题分解为更小问题的分解过程 divide
		把各个小问题的答案合并为原问题答案的合并过程 merge
		不需要再分解而直接解答的最基本问题 base case
	适用分治的问题必须具备以下几个特性:
		能够把问题自然分解为两个以上的子问题,且能够利用子问题的答案生成原问题的答案.优点在于很多情况下能更快解决同一问题.
		/*利用分治算法求1到n之和*/
		//必要条件: n是自然数
		//返回1+2+...+n的值
		int fastSum(int n){
			//初始部分
			if(n == 1) return 1;
			if(n % 2 == 1) return fastSum(n - 1) + n;
			return 2*fastSum(n/2) + (n/2) * (n/2); 
		}
	
