#include "dp_1_methods.h"

using namespace std  ;

/*
    能用动规解决的问题的特点

        1) 问题具有最优子结构性质。
            如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。

        2) 无后效性。
            当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。
*/


/*

 最长公共子序列（POJ1458)

    给出两个字符串，求出这样的一个最长的公共子序列的长度：子序列中的每个字符都能在两个原串中找到， 而且每个字符的先后顺序和原串中的先后顺序一致。

    Sample Input

        abcfbc abfcab

        programming    contest

        abcd    mnp

    Sample Output

        4

        2

        0
*/

/*
解题思路：
设输入的两个串为s1,s2,
设MaxLen(i,j)表示:：s1的左边i个字符形成的子串，与s2左边的j个字符形成的子串的最长公共子序列的长度(i,j从0 开始算），则MaxLen(i,j) 就是本题的“状态”
假定 len1 = strlen(s1),len2 = strlen(s2），那么题目就是要求   MaxLen(len1,len2)

显然：
    MaxLen(n,0)  = 0  ( n= 0…len1）
    MaxLen(0,n)  = 0  ( n=0…len2）

于是，我们可以得到如下的递推公式：
                if( s1[i - 1] == s2[ j - 1])
                    MaxLen(i,j) = MaxLen(i-1,j-1) + 1;
                else
                    MaxLen(i,j) = Max( MaxLen(i,j-1), MaxLen(i-1,j) );
*/
int dp_commonSubsequence(){
    char s1[100],s2[100];
    int max_len[100][100];

    while (cin >> s1 >> s2 ) {

        int len1 = strlen(s1);
        int len2 = strlen(s2);
        int i =0 , j = 0 ;

        /* boundary condition */
        for ( i = 0 ; i <= len1 ; i++)
            max_len[i][0] = 0;
        for ( j = 0 ; j <= len2 ; j++)
            max_len[0][j] = 0;

        for(i = 1 ; i <= len1; i++){
            for( j = 1 ; j <= len2 ; j++){
                if( s1[i - 1] == s2[ j - 1])
                    max_len[i][j] = max_len[i-1][j-1] + 1;
                else
                    max_len[i][j] = max(max_len[i][j - 1] , max_len[i - 1][j]);

            }
        }
         return max_len[len1][len2];
    }

}




/*
最长上升子序列(百练2757)

一个数的序列ai，当a1 < a2 < ... < aS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ..., aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，
这里1 <= i1 < i2 < ... < iK <= N。
比如，对于序列(1, 7, 3, 5, 9, 4, 8)， 有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).。
你的任务，就是对于给定的序列，求出最长上升子序列的长度。

输入数据
    输入的第一行是序列的长度N (1 <= N <= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。

输出要求
    最长上升子序列的长度。

输入样例

    7

    1 7 3 5 9 4 8

输出样例

    4

*/

/*
解题思路

1.找子问题

    “求序列的前n个元素的最长上升子序列的长度”是个子问题，但这样分解子问题，不具有“无后效性”，因为假设F(n) = x,但可能有多个序列满足F(n) = x。
    有的序列的最后一个元素比 an+1小，则加上an+1就能形成更长上 升子序列；
    有的序列最后一个元素不比an+1小……以后的事情受如何达到状态n的影响，不符合“无后效性” ，因此我们必须换一种思路来解决此问题。

    “求以ak（k=1, 2, 3…N）为终点的最长上升子序列的长度”，一个上升子序列中最右边的那个数，称为该子序列的 “终点”。
    虽然这个子问题和原问题形式上并不完全一样，但是只要这N个子问题都解决了，那么这N个子问题的解中， 最大的那个就是整个问题的解。

2.确定状态

    子问题只和一个变量—— 数字的位置相关。因此序列中数的位置k就是“状态”，而状态 k 对应的“值”，就是以ak做为“终点”的最长上升子序列的长度。 状态一共有N个。

3.找出状态转移方程

     maxLen (k)表示以ak做为“终点”的最长上升子序列的长度

    那么：

        初始状态：maxLen (1) = 1

        maxLen (k) = max { maxLen (i)：1<=i < k 且 ai < ak且 k≠1 } + 1       若找不到这样的i,则maxLen(k) = 1

        maxLen(k)的值，就是在ak左边，“终点”数值小于ak ，且长度最大的那个上升子序列的长度再加1。因为ak左边任何“终点”小于ak的子序列，加上ak后就能形成一个更长的上升子序列。

*/


/*
有了这个思路，我们就可以很轻松地写出代码了。然而，即使到了这里，我们依然还能从两个方向解决这道题，
我们可以将它们分别称为“人人为我”递推型动归和“我为人人”递推型动归

“人人为我”递推型动归
    状态i的值Fi由若干个值 已知的状态值Fk,Fm,..Fy 推出，如求和，取最大值
*/
int dp_increaseSubsequence(){
    int a[101];         /*save original datas*/
    int max_len[101];   /*save results*/

    int n;
    cin >> n;
    for(int i = 1 ; i <= n ; i++){
        cin >> a[i];
        max_len[i] = 1;
    }

    for( int i = 2; i <= n ;i ++)
        for( int j = 1; j < i ; j++)
            if ( a[i] > a[j] )
                max_len[i] = max( max_len [i] , max_len[j] + 1);

    cout<< * max_element(max_len+1 , max_len + n +1 ) << endl;
    return 0;
}

/*
“我为人人”递推型动归
    状态i的值Fi在被更新（不一定是 最终求出）的时候，依据Fi去更 新（不一定是最终求出）和状态i 相关的其他一些状态的值 Fk,Fm,..Fy
*/
int dp_increaseSubsequence_1(){

    int a[101];         /*save original datas*/
    int max_len[101];   /*save results*/

    int n;
    cin >> n;
    for(int i = 1 ; i <= n ; i++){
        cin >> a[i];
        max_len[i] = 1;
    }

    for( int i = 2; i <= n ;i ++)
        for( int j = i + 1; j <= n ; j++)
            if ( a[j] > a[i] )
                max_len[j] = max( max_len [j] , max_len[i] + 1);

    cout<< * max_element(max_len+1 , max_len + n +1 ) << endl;
    return 0;
}

/*
动规的三种形式

1）记忆递归型
    优点：只经过有用的状态，没有浪费。递推型会查看一些 没用的状态，有浪费。
    缺点：可能会因递归层数太深导致栈溢出，函数调用带来额外时间开销。总体来说，比递推型慢。

2) “我为人人”递推型
    没有什么明显的优势，有时比较符合思考的习惯。个别特殊题目中会比“人人为我”型节省空间。

3）“人人为我”递推型
    在选取最优备选状态的值Fm,Fn,…Fy时， 有可能有好的算法或数据结构可以用来显 著降低时间复杂度。﻿﻿
*/


/*
2019-7-17练习

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

    输入: [1,2,3,1]
    输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
         偷窃到的最高金额 = 1 + 3 = 4 。

示例 2:

    输入: [2,7,9,3,1]
    输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
         偷窃到的最高金额 = 2 + 9 + 1 = 12 。
*/
int dp_stealhouse(){
    int house[100];  //house[i] saves the amount of
    int i = 0;

    int len = 0;
    char ch;

    while (1) {
        cin >> house[i];
        //cout << house[i] << " ";
        i++;
        if(cin.get() == '\n')
            break;
    }

    //TODO


    return 0;
}
